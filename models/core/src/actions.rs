use std::collections::HashMap;

use chrono::DateTime;
use chrono::Utc;
use serde::Deserialize;
use serde::Serialize;
use serde_json::Value as Json;
use uuid::Uuid;

use replicante_models_agent::actions::ActionHistoryItem;
use replicante_models_agent::actions::ActionModel as ActionWire;
use replicante_models_agent::actions::ActionState as ActionStateWire;

pub use replicante_models_agent::actions::ActionRequester;

/// Action state and metadata information.
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct Action {
    // ID attributes.
    pub cluster_id: String,
    pub node_id: String,
    pub action_id: Uuid,

    // Record attributes.
    /// Action-dependent arguments attached to the action.
    pub args: Json,
    /// Timestamp of action creation.
    pub created_ts: DateTime<Utc>,
    /// Timestamp action entered a final state (success or failure).
    pub finished_ts: Option<DateTime<Utc>>,
    /// Headers attached to the action.
    pub headers: HashMap<String, String>,
    /// Identifier of the action logic to execute.
    pub kind: String,
    /// Entity (user or system) that requested the action.
    pub requester: ActionRequester,
    /// Count failed action scheduling attempts to prevent endless attempts.
    pub schedule_attempt: i32,
    /// Timestamp the action was scheduled on the agent.
    pub scheduled_ts: Option<DateTime<Utc>>,
    /// State the action is currently in.
    pub state: ActionState,
    /// Action-dependent state data, if the action needs to persist state.
    pub state_payload: Option<Json>,

    // TODO: remove this in favour of simpler approximate-view.
    /// Random number generated at the start of a sync cycle.
    pub refresh_id: i64,
}

impl Action {
    pub fn new<S1, S2>(cluster_id: S1, node_id: S2, refresh_id: i64, action: ActionWire) -> Action
    where
        S1: Into<String>,
        S2: Into<String>,
    {
        Action {
            action_id: action.id,
            args: action.args,
            cluster_id: cluster_id.into(),
            created_ts: action.created_ts,
            finished_ts: action.finished_ts,
            headers: action.headers,
            kind: action.kind,
            node_id: node_id.into(),
            refresh_id,
            requester: action.requester,
            schedule_attempt: 0,
            scheduled_ts: Some(action.scheduled_ts),
            state: action.state.into(),
            state_payload: action.state_payload,
        }
    }

    /// Mark the action as finished and sets the finish timestamp to now.
    pub fn finish(&mut self, state: ActionState) {
        self.state = state;
        self.finished_ts = Some(Utc::now());
    }
}

/// Approval requirements for action scheduling.
#[derive(Clone, Eq, PartialEq, Hash, Debug, Serialize, Deserialize)]
pub enum ActionApproval {
    /// Approval is granted and the action can be scheduled.
    #[serde(rename = "granted", alias = "GRANTED", alias = "Granted")]
    Granted,

    /// Approval from a user is required and the action CANNOT be scheduled yet.
    #[serde(rename = "required", alias = "REQUIRED", alias = "Required")]
    Required,
}

impl Default for ActionApproval {
    fn default() -> ActionApproval {
        ActionApproval::Granted
    }
}

/// Action history metadata and transitions.
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct ActionHistory {
    // ID attributes.
    pub cluster_id: String,
    pub node_id: String,
    pub action_id: Uuid,

    // Action history attributes.
    pub finished_ts: Option<DateTime<Utc>>,
    pub origin: ActionHistoryOrigin,
    pub timestamp: DateTime<Utc>,
    pub state: ActionState,
    pub state_payload: Option<Json>,
}

impl ActionHistory {
    pub fn new<S1, S2>(
        cluster_id: S1,
        node_id: S2,
        history: ActionHistoryItem,
        origin: ActionHistoryOrigin,
    ) -> ActionHistory
    where
        S1: Into<String>,
        S2: Into<String>,
    {
        ActionHistory {
            cluster_id: cluster_id.into(),
            node_id: node_id.into(),
            action_id: history.action_id,
            finished_ts: None,
            origin,
            timestamp: history.timestamp,
            state: history.state.into(),
            state_payload: history.state_payload,
        }
    }
}

/// System component that generated a transition history item.
#[derive(Clone, Eq, PartialEq, Hash, Debug, Serialize, Deserialize)]
pub enum ActionHistoryOrigin {
    /// The transition item was generated by an agent and synced.
    #[serde(rename = "AGENT")]
    Agent,

    /// The transition item was generated by Replicante Core.
    #[serde(rename = "CORE")]
    Core,
}

/// Current state of an action execution.
#[derive(Clone, Eq, PartialEq, Hash, Debug, Serialize, Deserialize)]
pub enum ActionState {
    /// The action was interrupted or never executed.
    #[serde(rename = "CANCELLED")]
    Cancelled,

    /// The action finished successfully.
    #[serde(rename = "DONE")]
    Done,

    /// Unable to successfully execute the action.
    #[serde(rename = "FAILED")]
    Failed,

    /// Agent records of an action were purged before Core synced them.
    #[serde(rename = "LOST")]
    Lost,

    /// The Replicante Agent knows about the action and will execute it when possible.
    #[serde(rename = "NEW")]
    New,

    /// Replicante is waiting for a user to approve the action before scheduling it.
    #[serde(rename = "PENDING_APPROVE")]
    PendingApprove,

    /// Replicante knows about the action and may or may not have sent it to the Agent.
    #[serde(rename = "PENDING_SCHEDULE")]
    PendingSchedule,

    /// The action is running on the Replicante Agent.
    #[serde(rename = "RUNNING")]
    Running,
}

impl From<ActionStateWire> for ActionState {
    fn from(state: ActionStateWire) -> ActionState {
        match state {
            ActionStateWire::Done => ActionState::Done,
            ActionStateWire::Failed => ActionState::Failed,
            ActionStateWire::New => ActionState::New,
            ActionStateWire::Running => ActionState::Running,
        }
    }
}
